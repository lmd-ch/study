谨以此文献给迷失在二分查找中的青春岁月
⚠️ ⚠️ ⚠️ 本文巨长，(可能)比你见过的所有二分查找解析文都要长，正文全文2w余字，主体内容阅读亦需1h以上。

电梯直达评论区🚀

不大不小中喜讯：「从入门到XX」系列发布了如下第二篇和第三篇，期待大家的阅读和指正！

并查集从入门到出门(以并查集发明人的视角)

十大排序从入门到入赘 （已被官方推荐置顶 🎉😄）

[2022-05-20]

在「模版二」中新增 「再论 r 的初始值」，分析并指出使用「模版二」时，何种情况可以不必使 r 初始时为 r = nums.length，而是设置为与「模版一」一样的 r = nums.length - 1。

为优化阅读体验，更改了文章部分布局。将本文的更新日志挪至文末，将「提前溢出」、「二分查找趣闻」、「关于名称」合入「拓展阅读」一节中，并将该节移至「总结」一节之后。

在「实战应用」中增加今日每日一题题解。（绝了，连着三天二分题，这是官方在给我这篇文章引流吗 😂😂😂，感谢官方！）

5/18: 668. 乘法表中第k小的数

5/19: 462. 最少移动次数使数组元素相等 II

5/20: 436. 寻找右区间

「实战应用」目前累计有这些二分题目，推荐看完本文后集中做掉：
704/69/374/33/153/154/81/278/162/34/35/74/658/29/875/668/442/436

没想到第一次尝试在讨论区发文，竟然真的有那么多人会看，发布以来在热门讨论榜上连续常驻 15 天，目前阅读数 15000+ ，收藏 1200+，点赞 200+， 看来基础内容的总结分享也是十分有意义的一件事，非常开心👀。我会再更新一些内容，如果大家发现文章中的任何纰漏，请一定不吝赐教，我会及时修正 👀，多谢！

如果你目前对二分查找算法仍有类似下面灰框中的疑惑，这篇文章就是为你准备的，看完并完全理解本文，包括且不仅限于这些疑惑，(基本上)都将一扫而空。另外经过多次新增内容，本文长度接近失控，并且看起来不像是讲解「二分查找」这种简单算法应该有的规模。不过我还是想说，作者意在try best effort to 展示二分查找两个常用模版的全貌，许多情形的代码十分相似，但我都逐一讲解，对于一般介绍「二分查找」文章中涉及的概念，我也尽可能做了覆盖。总之就是试图（企图）对二分做一个一劳永逸的再不回头的了断。另外就是后面一半的内容其实是「实战应用」，是十几道从易到难的二分题的题解。总之如果只是想找一两个行之有效的模版进行记忆，那么全面阅读本文可能性价比不高，但我仍然建议你（有时间的话）可以做一个透彻理解二分的尝试，毕竟强如算法鼻祖级人物的Knuth也说了，二分的细节可能让人无法招架（典出Binary Search Algorithm）。

尽管二分查找的基本思想相对简单，但细节可以令人难以招架 ... — 高德纳


左右边界初始值为何有时候是nums.length, 有时候是nums.length - 1?
什么是「左闭右闭」、「左闭右开」？
大家说的「模版一」、「模版二」都是怎么定义的，我怎么知道哪个是「一」哪个是「二」？
什么是lower_bound, upper_bound？
while中的条件什么时候用 <，什么时候用 <= ?
中间值下标为什么写成 l + (r - l) / 2 ？
左右界更新条件的不等号该写哪一个 <, <=, >, >= ?
左右界更新语句该写哪一个 l = c + 1 / l = c / r = c - 1 / r = c ？
为什么我写的二分会陷入无限循环？
循环终止时l、r下标的关系是怎么确定的，为什么是确定的？
返回值到底是 l 还是 r 还是 l - 1, l + 1, r - 1, r + 1...？
听说二分查找不需要数组有序，只需要具备「二段性」即可，元素大小甚至可以是随机的？really？
什么叫「二段性」？
据说有些什么「求最大值最小化」问题，是很抽象的二分问题？这又是什么意思？
为什么这么简单的算法思想却这么难写对。。。
鉴于当前篇幅略长，展示目录如下，你可以选择感兴趣的章节阅读。
[TOC]

以下是正文

前言：
前一阵在用二分解题时出现了让我相当费解的无限循环问题，我本来以为自己已经通过深刻把握「循环不变」而彻底拿捏了二分查找，没想到还是有漏洞，于是花了一些时间研究无限循环问题产生的原因，并且重新全面审视二分查找算法。一开始只是为了解决无限循环的问题，但为了确保自己确实搞懂了二分，花了些时间总结成了这篇文章。后来按照自己总结的思路又做了十几个二分的题，基本都能无思考阻滞快速拿下。所以我希望这篇文章能够消除你对二分查找的大部分困惑（如果你有困惑的话）。总之如果你还没法坚信自己写的每一份二分代码都是bug free的，可以看下这篇文章。行文可能会很啰嗦，但目的是把想说的都尽可能说清楚，期盼与你互相交流，共同进步。

二分查找以其原理极为简单，但细节处理却极易出错而闻名。 在本文中，我将以 「循环不变」 为中心，讨论两种常见的二分查找实现模版，尝试展现「循环不变」原理如何帮助我们跳出二分的「变化」过程，在「不变」的帮助下准确地理解模版代码的工作过程及其正确性，并在此基础上能够应对各种不同的二分场景写出bug free的代码。

在两个模版的介绍中，我将依次给出 「相等返回」情形 的写法和四种 「一般」情形 的写法，所有情形的实现在模版一中都是正确无误的，但在模版二中，同样遵循「循环不变」原则的「一般」写法，若不以正确形式给出，就有可能陷入无限循环。我将仔细证明为何看似正确的代码会陷入无限循环，以及如何通过细微的调整将其修正为正确的代码。（受「知心猛男」提醒而得，再次感谢）。

模版一 (错位终止/左闭右闭)
相等返回情形
以一道最基本的二分查找题目704. 二分查找为例开始讲解。最常见的模版一实现的代码如下，实际上这是模版一我称之为 「相等返回」 的特例，后续给出四种一般情形的模版一代码中，有两种情形能够涵盖「相等返回」。代码中的l、r、c代表搜索空间左界 (left)，右界 (right) 和中间值 (center) 下标。

704-二分查找:

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。


// 模版一「相等返回」写法
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while(l <= r){ // 循环条件
            int c = l + (r - l) / 2; // 中间值坐标
            if(nums[c] == target) return c; // 相等返回
            else if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target
            else r = c - 1; // #2 更新后r右侧元素「必」大于target 
        }
        return -1; 
    }
}
※ 求中间值下标的语句，不用 int = (l + r) / 2，而采用int c = l + (r - l) / 2的写法乃是为了防止「提前溢出」。在Java中有三种常见写法，因该内容不是此处重点，此处不做介绍，请参考「拓展阅读」一节中的「提前溢出」和「二分查找趣闻」。
※ 「错位终止/相等终止」，「左闭右闭/左闭右闭」的名称相关闲话，见「拓展阅读」一节的「关于名称」。

「循环不变」与程序正确性
跟踪循环中变化的细节是困难的，因此我们需要找到一些在整个循环过程中都不会发生变化的「量」或「关系」，以便得到循环结束后某些确定的结论。在这个实现中， #1和#2两行保证了如下「关系」是 「循环不变」 的：

对于#1行，若进入该分支，则 l 下标更新后其左侧元素「必」小于target。

对于#2行，若进入该分支，则 r 下标更新后其右侧元素「必」大于target。

在程序运行过程中，中间值要么等于target直接返回答案，要么执行#1或#2。基于上述两个不变的关系，若执行#1，则更新后的 l 左侧元素为target的可能性被完全排除，若执行#2，则更新后的 r 右侧元素为target的可能性被完全排除。再次强调，这两个「关系」对于更新后任意时刻的 l 和 r 来说都是「不变」的。同时强调的是「更新后」这一前提，因为若target比nums中所有元素都大，则 r 不会经历更新，若target比nums中所有元素都小，则 l 不会经历更新。不经历更新，就不具有前述两条「循环不变」的关系。例如target大于nums中所有元素时，r 不更新，最终r = nums.length - 1，l = nums.length, l 经历过更新，此时说 l 左侧元素必小于target是正确的，但 r 右侧元素必大于target是不成立的（r右侧没有元素）。这一点在「一般」情形中会影响返回时的判断，后续还会说明。不过在这个「相等返回」写法中，显然无需考虑 l, r 是否有过更新。

程序执行过程中的两种情况：

情况一：nums[c] == target，直接返回正确的结果。

情况二：while因 l 与 r 不满足 l <= r 而终止。现在来看循环终止时 l 与 r 的关系。while的每一次执行，要么 l 比 c 的位置右移一位，要么 r 相比当前 c 的位置左移一位，while终止条件为 l > r，通过几个例子很容易推出终止时 l 与 r 的关系「必」为 r = l - 1（见后续「错位终止图示」），即while终止时，r 与 l 相邻，r 在 l 左侧一位。 前述我们已经强调过，对于更新后任意时刻的 l，其左侧元素必不存在target，对于更新后任意时刻的 r，其右侧元素必不存在target。而while终止时 r 的右侧和 l 的左侧 正好覆盖了所有nums的元素，此时可以 断言 ：target必不在nums中。若target大于nums中所有元素，虽然 r 不更新，但最终 l 的左侧覆盖了所有元素。同样地，target小于nums中所有元素时，l 虽不更新，但最终 r 的右侧覆盖了所有元素，断言都能够成立。



至此，通过分析「循环不变」关系，我们明确了上述代码的 正确性 ，并理解了其正确的根本原因。

【错位终止图示】



四种一般情形
「相等返回」的写法很好理解，现在来看更一般的情形。所谓「一般」是指要求返回 大于等于 / 大于 / 小于等于 / 小于 target的数字下标。其一般性在于这种不等于的要求涵盖了前述等于的情形。这里将与target相等的元素的下标称作「等于下标」，大于target的元素中最小的那个的下标称作「刚好大于下标」，同理有「刚好小于小标」，不存在所要求的元素时返回-1。具体如下：

情形1: 大于等于。有相等元素时返回等于下标，否则返回刚好大于下标，否则返回 -1。（704题要求返回等于下标或-1）

情形2: 大于。不考虑相等，返回刚好大于下标，否则返回-1。

情形3: 小于等于。有相等元素时返回等于下标，否则返回刚好小于下标，否则返回 -1。（704题要求返回等于下标或-1）

情形4: 小于。不考虑相等，返回刚好小于下标，否则返回-1。

无论是哪种情形，我们都可以根据「循环不变」原则给出相应的更「一般」的模版一代码。后续我会简单展示 Java / C++ / Python 的二分查找相关源码。其中C++中的lower_bound和Python的bisect_left就对应「情形1（大于等于）」，upper_bound(C++) 和 bisect_right (Python)对应「情形2（大于）」，只是对返回规则的定义与与我们的规则有所不同。另外，Java中的binarySearch采用的是「相等返回」情形，关于这些我将在「各语言内置二分查找方法(函数)」中说明。现在先讲解如下「情形1」的代码。


// 模版一「一般」情形1: 大于等于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target
            else r = c - 1; // #2 更新后r右侧「必」大于等于target
        }
        // return (l == nums.length || nums[l] != target) ? -1 : l; // 704题的返回，处理:相等/不等
        return l == nums.length ? -1 : l; // 处理: 相等/刚好大于/不存在
    }
}
在理解了「循环不变」原理后，编写这个版本的代码时尝试寻找 l 或 r 更新后是否能有类似target必在或必不在某个确定的范围的「循环不变」关系。因为情形1要求「大于等于」，考虑其 「补关系」 ，即若target小于nums[c]，那么 l 更新后就有如下「循环不变」关系1。与「相等返回」不同的是，因为没有判等分支， 进入#2 行的条件是 nums[c] >= target，得到如下「循环不变」关系2。

对于#1行，若进入该分支，则 l 下标更新后其左侧元素「必」小于target。

对于#2行，若进入该分支，则 r 下标更新后其右侧元素「必」大于等于target。

同样地，while终止时有 r = l - 1，根据本情形的「循环不变」关系，此时target必不在 l 左侧，而 r 的右侧必大于等于target，又因为nums是单调的，因此 断言: l 要么是等于下标，要么是刚好大于下标。稍等，循环不变只保证了左右侧元素与target的大小关系，并不保证 l 或 r 最终一定在nums的下标范围内。实际上有可能超出一位，即为 r = -1 (nums中所有数都大于target) 或 l = nums.length (nums中所有数都小于target)。因此前述断言还有一个前提，即 l != nums.length，这个条件通过思考 target的三种情况 提炼。

nums中所有元素都小于target时，r 不更新，最终 l = nums.length，因此当这个关系成立时，返回 -1。

nums中存在元素大于等于target时，由两条「循环不变」关系（或者下图）可知应返回 l 。

nums中所有元素都大于target时，l 不更新，l = 0，此时应当返回下标0，而刚好有l = 0，因此返回 l 。

于是一个判断即可对应三种情况(后两种都返回 l)。另外，因为 r = l - 1，用 l 或 r来返回都是可以的。



下面给出余下情形的代码，分析过程是类似的，不再赘述。其中「情形2(大于)」和「情形4(小于)」不考虑「等于」关系，不能用于处理704题，而「情形1(大于等于)」和「情形3(小于等于)」涵盖了「等于」，可以用来处理704题，只需要在返回值语句上稍作修改即可，细节请见代码。

「情形2」考虑target的三种情况：

nums中所有元素都小于target时，r 不更新，最终 l = nums.length，因此当这个关系成立时，返回 -1。

nums中存在元素大于target时，由两条「循环不变」关系可知应返回 l (r 的右侧)。

nums中所有元素都大于target时，l 不更新，l = 0，此时应当返回下标0，而刚好有l = 0，返回 l 。

「情形2」与「情形1」只有一个 '=' 字符的差别。事实上这些代码都十分相似，但差之毫厘谬以千里，需要谨慎对待。


// 模版一「一般」情形2: 大于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] <= target) l = c + 1; // #1 更新后l左侧元素「必」小于等于target
            else r = c - 1; // #2 更新后r右侧「必」大于target
        }
        return l == nums.length ? -1 : l; // 处理: 刚好大于/不存在
    }
}
「情形3」考虑target的三种情况：

nums中所有元素都小于target时，应当返回最大下标 nums.length - 1，r未更新，仍有 r = nums.length - 1，因此返回 r。

nums中存在元素小于等于target时，由两条「循环不变」关系可知应返回 r (l 的左侧)。

nums中所有元素都大于target时，l 不更新，l = 0，此时应当返回-1，而此时刚好有r = -1，因此返回 r。

意外地发现三种情况都返回 r。但若用此情形处理704题，则需调整，请参考注释行。


// 模版一「一般」情形3: 小于等于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] <= target) l = c + 1; // #1 更新后l左侧「必」小于等于target
            else r = c - 1; // #2 更新后r右侧「必」大于target
        }
        // return (r == -1 || nums[r] != target) ? -1 : r; // 704题的返回，处理:相等/不等
        return r; // 处理: 相等/刚好小于/不存在
    }
}
「情形4」考虑target的三种情况：

nums中所有元素都小于target时，应当返回最大下标 nums.length - 1，r未更新，仍有 r = nums.length - 1，因此返回 r。

nums中存在元素小于target时，由两条「循环不变」关系可知应返回 r (l 的左侧)。

nums中所有元素都大于target时，l 不更新，l = 0，此时应当返回-1，而刚好有r = -1，因此返回 r。

三种情况也都返回 r，「情形4」与「情形3」只有一个 '=' 字符的差别。


// 模版一「一般」情形4: 小于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target
            else r = c - 1; // #2 更新后r右侧「必」大于等于target
        }
        return r; // 处理: 相等/刚好小于/不存在
    }
}
现在来展示一种我认为不太好的 「逆习惯」 写法（如下，以情形1为例），该写法把 r 的更新写在 l 之前，这仅仅是把 if-else 处理调换了位置而已，不影响程序正确性。展示这种写法是想建议大家在书写二分查找代码时保持同一种风格和习惯，这样能够减少思考负担。


// 模版一「一般」情形1: 大于等于 (「逆习惯」写法)
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] >= target) r = c - 1; // #1 更新后r右侧「必」大于等于target
            else l = c + 1; // #2 更新后l左侧元素「必」小于target
        }
        // return (l == nums.length || nums[l] != target) ? -1 : l; // 704题的返回，处理:相等/不等
        return l == nums.length ? -1 : l; // 处理: 相等/刚好大于/不存在
    }
}
模版一总结
核心在于「错位终止」，即循环终止时有 r = l - 1。而最终的「错位」是通过每次 l 和 r 的更新为 l = c + 1, r = c - 1来实现的。换句话说，「模版一」的标志是while中的 l <= r 以及 l 与 r 更新时的 l = c + 1, r = c - 1，二者相辅相成，共同作用实现了「错位终止」。另外 l 与 r 的初始取值的「左闭右闭」特点也是「模版一」的一个标志。

通过 l 左侧和 r 右侧的「循环不变」关系，确定while终止后的目标下标。在「一般」情形中，要考虑 不更新导致的越界 及其对应的返回前判断。

相等或不等的情形都可以用「一般」版本，但相等情形应当用「相等返回」版本，能够在找到相等元素时立即返回结果，一般版本则一定会穷尽二分过程。

模版二 (相等终止/左闭右开)
相等返回情形
与「模版一」相映，「模版二」的特点在于 「相等终止」 ，即while终止时，l = r。l 与 r 在while循环终止时的关系由它们的更新语句 l = c + 1和 r = c 所决定，如同模版一的分析那样，请参考后续「相等终止图示」。在探究这个模版代码的「循环不变」之前，先行强调，如果 l 与 r 的初始值设置为与「模版一」相同，即 l = 0, r = nums.length - 1，那么由于while的条件是 l < r，当nums只有一个元素时，将无法进入while，因此为了能够至少进入一次while，模版二中 r 的初始值为 r = nums.length，而更主要的原因是当target大于nums中所有元素时，r = nums.length 将是这一情况的一个标志，倘若 r 初始值为 nums.length - 1，只看 r 的最终取值是无法判断为上述情况的，仍需要比较一次target与nums中的最后一个元素。在后续「情形3」和「情形4」的代码中还可以进一步体会将 r 初始值设置为 r = nums.length 带来的统一返回值的好处。总之，r = nums.length 是又一个模版二的标志，通常被称作 「左闭右开」 ，而模版一的 l 和 r 的初始取值被称作 「左闭右闭」。


// 模版二「相等返回」写法
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] == target) return c; // 找到目标值直接返回
            else if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target 
            else r = c; // nums[c] > target #2 更新后r及其右侧「必」大于target
        }
        return -1;
    }
}
此实现的「循环不变」关系为：

对于#1行，若进入该分支，则 l 下标更新后其左侧元素「必」小于target。

对于#2行，若进入该分支，则 r 下标更新后其及其右侧元素「必」大于target。

同样地，程序执行过程中有两种情况：

情况一：nums[c] == target，直接返回正确的结果。

情况二：while因 l 与 r 不满足 l < r 而终止，此时 l = r （见后续「相等终止图示」）。由「循环不变」关系，对于更新后任意时刻的 l ，其左侧元素必小于target，对于更新后任意时刻的 r，r 及其右侧的元素必定大于target。



while终止时，l = r。 与「模版一」的「相等返回」分析类似，情况二while终止时 r 及其右侧和 l 的左侧正好覆盖了所有nums的元素，此时可以断言：target必不在nums中。若target大于nums中所有元素，虽然 r 不更新，但最终 l 的左侧覆盖了所有元素(l = r = nums.length)。同样地，target小于nums中所有元素时，l 虽不更新，但最终 r 及其右侧覆盖了所有元素，断言都能够成立。

【相等终止图示】



四种一般情形
四种一般情形与模版一时所述相同。为引入「无限循环问题」，先给出「情形1」和「情形3」的代码，均依据「循环不变」原则写出，要注意现在的「情形3」代码是错误的。

「情形1」考虑target的三种情况：

nums中所有元素都小于target时，r 不更新，最终 r = nums.length，因此当这个关系成立时，返回 -1。

nums中存在元素大于等于target时，由两条「循环不变」关系可知应返回 r。

nums中所有元素都大于target时，l 不更新，最终 l = r = 0，我们需要返回下标0，而此时 r 正好等于0。

一条判断对应三种情况(两个分支)。若用于处理704题，返回时的判断需做调整，见注释行。


// 模版二「一般」情形1: 大于等于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target 
            else r = c; // #2 更新后r及r右侧「必」大于等于target
        }
        // return (r != nums.length && nums[r] == target) ? r : -1; // 704题的返回，处理:相等/不等
        return r != nums.length ? r : -1; // 处理:等于/刚好大于/不存在
    }
}
此处「情形3」为错误代码，不过多分析，专注于后续的「无限循环」分析。


// 模版二「一般」情形3：小于等于（注意！！！此版本有可能发生无限循环）
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] <= target) l = c; // #1 更新后l及l左侧元素「必」小于等于target 
            else r = c - 1; // #2 更新后r右侧「必」大于target
        }
        // return (r != -1 && nums[l] == target) ? l : -1; // 704题的返回，处理:相等/不等
        return r != -1 ? l : -1; // 处理:等于/刚好大于/不存在
    }
}
在实际运行上述代码后，「情形1」准确无误地返回所有结果，但「情形3」却意外地陷入了无限循环。在分析此无限循环现象之前，先提一下这个错误版本的返回语句。可以看到返回语句中竟然用到了 r 和 l，之前的分析不是已经指出while循环结束后 r = l 了吗？有必要再推导一次此版本代码的终止情形，如下。



可以看到，终止情形有两种，第二种将有可能导致 r 越界，即当target小于nums中任何一个数时， l 不发生更新 (l == 0)，最终 r = l - 1终止。正因为存在这样的终止情形，所以返回语句中 r 和 l 才会同时存在。总之虽然从两种终止情形中我们感觉到了一些坏味道，但这版代码看起来没什么问题。但我们已经知道了它可能会陷入无限循环，下面开始分析。

发生无限循环的条件及证明
在分析前多说几句，这部分内容在之后给出相应不发生无限循环的正确版本后，多少有些多余，也许还增加了阅读负担甚至可能会扰乱读者对模版的记忆。不过我想说的是，这篇总结的写作动机正是因为我遇到了这个无限循环的问题，当然这是因为当时对二分查找理解还不够透彻（现在也不敢说完全理解，但比之前好点）而写出的错误代码，哪怕它也是基于「循环不变」原理写出的。总之我希望把这个过程记录下来，也许有人也遇到过相同的情况而困惑不已，也许帮人解惑亦未可知。

首先「循环不变」关系在整个程序运行过程中是由 「因果律」 所保证的（一旦进入分支，必然更新相应的 l 或 r，必然使得 l 或 r 的左或右侧满足对应的「循环不变」关系），问题肯定不会出现在「循环不变」上。接着我们再来审视模版二的代码，并尝试从它与模版一的不同处着手。不难看到除了while条件的不同，最大的不同在于 l 和 r 的更新语句。模版一中 l 和 r 的更新都是在 c 的基础上错一位，但模版二中却有 可能保持与 c 相等。 循环中的变量只有l、r、 c，对于「情形1」，如果某一次循环进入else分支，使得 r = c，且进入本次循环时 r 原本就等于 c，那么 l 与 r 都将保持不变，c 由 l 与 r 得到，那么 c 也会继续保持不变，也就有可能发生无限循环。对于「情形3」也是如此，也有可能因为进入 l = c 分支而发生无限循环。我们已经知道「情形1」代码没问题，但「情形3」代码发生无限循环，现在逐个分析。为方便分析，将「情形1」和「情形3」的代码并列如下，左侧为「情形1」，右侧为「情形3」。



情形1的分析
发生循环只可能是如下场景：某一次进入while时， c = l + (r - l) / 2，使得 nums[c] >= target，进入else分支，r = c，且假设此次循环开始时就有 r = c，于是 l 与 r 在此次循环中不变，下一次循环首先计算的 c 也不变，循环产生。但实际运行结果告诉我们，程序没有问题，因此有必要检视上述假设的正确性。我们首先假设了 r = c，可以将计算 c 时的 c 换成 r，有 r = l + (r - l) / 2，我们知道这个式子与 r = (l + r) / 2相等，只是为了防止溢出才写成前一种形式。为方便分析换回后一种简单形式。l + r 要么为偶数，要么为奇数：

l + r 为偶数时，能够被2整除，有 2r = l + r，即 r = l。但while条件已经限制了 l < r，l = r 时不可能进入while循环，故 r = c 的假设与 l + r 为偶数互相矛盾。

l + r 为奇数时，我们转换成 r = (l + r - 1) / 2，该式结果与奇数情形向下取整的结果相同，得到 r = l - 1，这显然也是不可能发生的，故r = c 的假设与 l + r 为奇数互相矛盾。

由此我们得出结论，左侧「情形1」的代码虽然看起来有可能产生循环，但发生循环的条件根本不可能达到，因此程序一定能够终止运行，又依据前述「循环不变」的原理，代码的正确性得以保证。

情形3的分析
分析过程一致。产生循环的条件是某一次进入while时，c = l + (r - l) / 2，使得 nums[c] <= target，于是进入 if 分支，l = c，且假设此次循环开始时 l = c。检视该假设的正确性，将计算 c 的式子中的 c 换成 l，有 l = (l + r) / 2。

l + r 为偶数时，l = r，与进入while的条件矛盾，故 l = c 的假设与 l + r 为偶数互相矛盾。

l + r 为奇数时，l = r - 1。意想不到的事情发生了，这是可能达到的一种情况。 也就是说，「情形3」代码在某一次进入while时，若 l = r -1，且nums[c] <= target时，将发生无限循环。

举个例子，对于数组 nums = {-1,0,3,5,9,12}，target = 3，以其为输入运行「情形3」代码，程序将在 l = 1, r = 2 （满足 l = r - 1，且此时nums[c] = nums[1] = 0 <= target = 3）时开始无限循环。但若target = 5，则程序正常结束，返回正确的结果（建议实际动手分析一下）。实际上只要target大于nums中所有数字，则必然发生无限循环，因为 r 不会更新， l 向 r 逐渐靠近后最终一定位于 r 的前一位，即 l = r - 1，而此时必然有 nums[c] <= target，于是会在这个时候陷入无限循环。

破除无限循环及正确写法
上述分析指出，导致陷入无限循环的关键在于 l = c 语句，从该语句推导出无限循环发生的条件是有可能出现的。因此对于「情形3」，我们需要稍加改造。改造点自然在 l = c 语句上。我们仍旧让这条更新语句为 l = c + 1，那么条件也要相应地改成 nums[c] < target，目的是要让这个「循环不变」关系成立：l 更新后其左侧元素「必」小于target。然后 r 的更新语句要调整回 r = c。两条「循环不变」关系与「情形1」一样：

对于#1行，若进入该分支，则 l 下标更新后其左侧元素「必」小于target。

对于#2行，若进入该分支，则 r 下标更新后 r 及其其右侧元素「必」大于等于target。



这时候我们会发现，不是又变回情形一了吗？没错，直到while结束前的语句，与情形一是完全一致的（因此终止情形也只有 l = r 一种）。当while结束后，l 左侧元素必小于target，r 及其右侧元素必大于等于target。我们只需在返回前调整一下判断，就能返回正确结果了。判断语句经由如下思考后写就。

nums中所有元素都小于target时，r 不更新，最终 r = nums.length，因此当这个关系成立时，返回 r - 1。

nums中存在元素小于等于target时，由两条「循环不变」关系可知，如果nums[r]等于target，需要返回 r，否则返回 r - 1。

nums中所有元素都大于target时，l 不更新，最终 l = r = 0，我们需要返回 -1，而此时 r - 1正好等于 -1。
可以看到，返回值仍旧是两种情形（r 或 r-1）。由此我们写出「模版二」的正确的「情形3」代码。


// 模版二「一般」写法之情形3（正确版1）
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target 
            else r = c; // #2 更新后r及其右侧「必」大于等于target
        }
        // return (r != nums.length && nums[r] == target) ? r : -1; // 704题的返回，处理:相等/不等
        return (r == nums.length || nums[r] != target) ? r - 1 : r; // 处理:相等/刚好小于/不存在
    }
}
关于 if-else 的条件和 l 与 r的更新，有必要再多说几句（其实行文中已经或明或暗地强调过多次）。 if-else 的条件和 l, r 更新语句是要根据返回需求来配合的，写法很灵活，也正是因为这样才容易写错。为了体现这一点，我再给出「情形3」的另一种正确版本。如下，到while结束之前，与上一个版本的写法只有 if 条件中一个 '=' 字符的差别。该差别使得两个「循环不变」关系为如下：

对于#1行，若进入该分支，则 l 下标更新后其左侧元素「必」小于等于target。

对于#2行，若进入该分支，则 r 下标更新后 r 及其其右侧元素「必」大于target。

仍旧考虑target的三种情况：

nums中所有元素都小于target时，r 不更新，最终 r = nums.length，因此当这个关系成立时，返回 r - 1。

nums中存在元素小于等于target时，由两条「循环不变」关系可知应返回 r - 1。

nums中所有元素都大于target时，l 不更新，最终 l = r = 0，我们需要返回 -1，而此时 r - 1正好等于 -1。

三者返回都是相同的 r - 1，由此我们得到如下「情形3」的正确版2。如果用来解决704题，见注释行。值得一提的是，若直接返回 r - 1，虽是正确的，但形式上却不容易看出 r = 0 时返回 -1 对应nums中所有元素都大于target这一情况，因此我们选择写成 return r > 0 ? r - 1 : -1; 这样的形式 (来自@masterx89 的建议)。


// 模版二「一般」写法之情形3(正确版2)
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] <= target) l = c + 1; // #1 更新后l及其左侧元素「必」小于等于target 
            else r = c; // #2 更新后r右侧「必」大于target
        }
        // 原先针对 704 的返回有漏洞，该修改（下面一行）来自 Hankai Xia @masterx89 同学，感谢
        // return (r > 0 && nums[r - 1] == target) ? r - 1 : -1; // 704题的返回，处理:相等/不等
        // return r - 1; // 通过分析target的三种情形得到的统一返回值
        return r > 0 ? r - 1 : -1; // 但写成此种形式，逻辑更佳 （来自Hankai Xia @masterx89 的建议）
    }
}
现在，给出模版二「情形2」和「情形4」的代码如下。同样地，这两种情形不涵盖等于，因此不用于704题。省略详细分析过程，给出target的三种情况时对应的返回，由前面的经验，我们能够立即看出代码的正确性。

「情形2」考虑target的三种情况：

nums中所有元素都小于target时，r 不更新，最终 r = nums.length，因此当这个关系成立时，返回 -1。

nums中存在元素大于target时，由两条「循环不变」关系可知应返回 r。

nums中所有元素都大于target时，l 不更新，最终 l = r = 0，我们需要返回下标0，而此时 r 正好等于0。


// 模版二「一般」情形2: 大于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] <= target) l = c + 1; // #1 更新后l左侧「必」小于等于target 
            else r = c; // #2 更新后r及r右侧「必」大于target
        }
        return r == nums.length ? -1 : r; // 处理:刚好大于/不存在
    }
}
「情形4」考虑target的三种情况：

nums中所有元素都小于target时，r 不更新，最终 r = nums.length，因此当这个关系成立时，返回 r - 1。

nums中存在元素小于target时，由两条「循环不变」关系可知应返回 l - 1 (即 r - 1)。

nums中所有元素都大于target时，l 不更新，最终 l = r = 0，我们需要返回 -1，而此时 r - 1 正好等于-1。


// 模版二「一般」情形4: 小于
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1; // #1 更新后l左侧元素「必」小于target 
            else r = c; // #2 更新后r及其右侧「必」大于等于target
        }
        return r - 1; // 处理:刚好小于/不存在
    }
}
再论r的初始值
本节开头，介绍「模版二」时提到，r 的初始值 r = nums.length 是「模版二」与「模版一」的一大不同。

为统一描述，后续记做 r = n + 1，n = nums.length - 1，n 表示搜索空间右界，r 初始为搜索空间右界 + 1。

该取值的主要的原因是当target大于nums中所有元素时，r 不更新，那么 r = n + 1 (nums.length) 将是是判断这一情况的标志。倘若 r 初始值为 n (nums.length - 1)，循环终止后 r 不变，则无法知道究竟是target大于nums中的所有元素，还是target为最后一个元素。但许多题目的答案保证了搜索空间内必有解，若为此种情形，则 r 的初始值就无需比搜索空间右界大1。虽然这将导致考察不到 c = n，但并不影响返回值的正确性，以下简单分析这一点。

「相等返回」情形，需要返回 c。若答案为最后一个元素，l = r = n 时循环终止，虽未能更新 c = n， 并通过 nums[c] == target来返回 c ，但因为除了此种情况，都会在while中返回，只有答案为最后一个元素时才会执行到最后的返回语句，因此可以直接在最后的return语句中返回nums[r]。

「大于等于」& 「大于」情形，需要返回 r 。若答案为最后一个元素，l = r = n 时循环终止，虽未能更新 c = n， 并通过 nums[c] >= target (大于等于) 或 nums[c] > target (大于) 来更新 r = c = n，但 r 不更新时刚好有 r = n，所以能够返回正确结果。

「小于等于」&「小于」情形，需要返回 r - 1。若答案为最后一个元素时，将无法通过 r - 1 (r - 1 = n - 1)来返回 n。但我们可以通过返回前判断是 nums[r - 1] 是否满足要求（根据具体要求），不满足时表示答案为最后一个元素（因为必存在解）。例如要求返回下标时，返回语句大致可以这么写 return nums[r - 1] <= target ? r - 1 : r;。再次强调，题目已经确保搜索空间中存在答案，必有r > 0。

具体例子有 162. 寻找峰值、278. 第一个错误的版本 、875. 爱吃香蕉的珂珂、668. 乘法表中第k小的数、462. 最少移动次数使数组元素相等 II，这些题目已经保证搜索空间中必有解，因此采用「模版二」时，初始时 r = n 也是正确的（无需写成 r = n + 1，即常规的搜索空间右界 + 1）。

通常我们只需要按 r = n + 1 的常规初始值来写即可，但在162. 寻找峰值中有可能导致越界（左界更新条件中出现了 nums[c + 1]），因此在 r = n 不影响正确性时，写成 r = n可以省去对越界情况的分析。不过若要写下 r = n，就意味着我们需要思考清楚是否不影响返回值正确性。总之仍要视情况而定，「再论 r 的初始值」主要是想强调，「模版二」解法中你可能会看到 r = n 的写法，这未必是错的，也就是说「模版二」并不意味着一定要将 r 初始值设置为 r = n + 1。

模版二总结
核心在于 「相等终止」，即循环终止时有 l = r。而最终的「相等」是通过每次 l 和 r 的更新为 l = c + 1, r = c 来实现的。换句话说，「模版二」的标志是while中的 l < r 以及 l 与 r 更新时的 l = c + 1, r = c，二者相辅相成，共同作用实现了「相等终止」。另外 l 与 r 的初始取值的「左闭右开」特点也是「模版二」的一个标志。

通过 l 左侧和 r 右侧的「循环不变」关系，确定while终止后的目标下标。

相等或不等的情形都可以用「一般」版本，但相等情形应当用「相等返回」版本，能够在找到相等元素时立即返回结果，而一般版本则一定会穷尽二分过程。

必须避免 l = c 更新分支的出现，否则在一定条件下会发生无限循环。

各语言内置二分查找方法(函数)
简单介绍Java / C++ / Python中的二分查找相关方法(函数)。就模版而言，Java和C++的二分方法(函数)采用了「模版一」，Python采用了「模版二」，就各自实现而言，在返回值上定义了不同的规则。

Java
JDK中内置的二分方法为binarySearch。内部调用了如下方法，可以看到使用的是「模版一」的「相等返回」写法。只在return上与我们给出的版本有差异。这个返回的意思是：

若找到等于key的元素，返回该元素下标（若有多个相等元素，返回其中之一的下标，不保证是哪一个）。

若找不到，则想象将key作为第n个元素插入(从第1个开始算起)，返回 -n。


private static int binarySearch0(int[] a, int fromIndex, int toIndex,
                                 int key) {
    int low = fromIndex;
    int high = toIndex - 1;

    while (low <= high) {
        int mid = (low + high) >>> 1;
        int midVal = a[mid];

        if (midVal < key)
            low = mid + 1;
        else if (midVal > key)
            high = mid - 1;
        else
            return mid; // key found
    }
    return -(low + 1);  // key not found.
}
C++
STL中的二分查找函数为 lower_bound / upper_bound / binary_search。
如下lower_bound 返回「大于等于」val的元素下标，采用的是「模版一」的「情形1」，与我们给出的版本的区别在return语句上，该函数不做判断，也就是说当val大于所有元素时，返回最后一个元素下标+1（即等同于我们的nums.length）。

※ distance函数返回从first(包括)到last(包括)元素总数，所以count > 0 其实就等同于 l <= r。


template <class ForwardIterator, class T>
  ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T& val)
{
  ForwardIterator it;
  iterator_traits<ForwardIterator>::difference_type count, step;
  count = distance(first,last);
  while (count>0)
  {
    it = first; step=count/2; advance (it,step);
    if (*it<val) {                 // or: if (comp(*it,val)), for version (2)
      first=++it;
      count-=step+1;
    }
    else count=step;
  }
  return first;
}
upper_bound返回「大于」val的元素下标，采用的是「模版一」的「情形2」，与我们给出的版本的区别在return语句上，该函数不做判断，也就是说当val大于所有元素时，返回最后一个元素下标+1（即类似nums.length）。


template <class ForwardIterator, class T>
  ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T& val)
{
  ForwardIterator it;
  iterator_traits<ForwardIterator>::difference_type count, step;
  count = std::distance(first,last);
  while (count>0)
  {
    it = first; step=count/2; std::advance (it,step);
    if (!(val<*it))                 // or: if (!comp(val,*it)), for version (2)
      { first=++it; count-=step+1;  }
    else count=step;
  }
  return first;
}
binary_search调用lower_bound，若找到返回true，不存在返回false。


template<class ForwardIt, class T>
bool binary_search(ForwardIt first, ForwardIt last, const T& value)
{
    first = std::lower_bound(first, last, value);
    return (!(first == last) && !(value < *first));
}
Python
Python中的二分函数为 bisect_left / bisect_right。
如下bisect_left返回「大于等于」x的元素下标，若都小于x，返回最后一个元素下标+1（即类似nums.length），与C++中的lower_bound一致，但使用的是「模版二」的情形1写法。


def bisect_left(a, x, lo=0, hi=None, *, key=None):
    """Return the index where to insert item x in list a, assuming a is sorted.
    The return value i is such that all e in a[:i] have e < x, and all e in
    a[i:] have e >= x.  So if x already appears in the list, a.insert(i, x) will
    insert just before the leftmost x already there.
    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.
    """

    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    # Note, the comparison uses "<" to match the
    # __lt__() logic in list.sort() and in heapq.
    if key is None:
        while lo < hi:
            mid = (lo + hi) // 2
            if a[mid] < x:
                lo = mid + 1
            else:
                hi = mid
    else:
        while lo < hi:
            mid = (lo + hi) // 2
            if key(a[mid]) < x:
                lo = mid + 1
            else:
                hi = mid
    return lo
bisect_right返回「大于」x 的元素下标，若都小于x，返回最后一个元素下标+1（即类似nums.length），与C++中的upper_bound一致，但使用的是「模版二」的情形2写法。


def bisect_right(a, x, lo=0, hi=None, *, key=None):
    """Return the index where to insert item x in list a, assuming a is sorted.
    The return value i is such that all e in a[:i] have e <= x, and all e in
    a[i:] have e > x.  So if x already appears in the list, a.insert(i, x) will
    insert just after the rightmost x already there.
    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.
    """

    if lo < 0:
        raise ValueError('lo must be non-negative')
    if hi is None:
        hi = len(a)
    # Note, the comparison uses "<" to match the
    # __lt__() logic in list.sort() and in heapq.
    if key is None:
        while lo < hi:
            mid = (lo + hi) // 2
            if x < a[mid]:
                hi = mid
            else:
                lo = mid + 1
    else:
        while lo < hi:
            mid = (lo + hi) // 2
            if x < key(a[mid]):
                hi = mid
            else:
                lo = mid + 1
    return lo
总结
本文详细介绍了二分查找中常用的两种模版，并以704. 二分查找为例展示了两种模版的「相等返回」情形和「一般」情形的写法。

细致地分析了各种实现中的「循环不变」关系，并指出如何通过这些不变的关系得到正确的答案。

着重强调了两种模版中与「循环不变」相关联的while条件及其对应的 l 与 r 的更新语句，并用图示简单展示了while终止时 l 与 r 的确定的等式关系。

在模版二中，从 l 与 r 更新语句出发（r = c, l = c），提出即便是遵循「循环不变」的实现，仍会发生无限循环的情形，并证明了该情形的发生条件。这一点指导我们在「模版二」的各类实现中，要避免 l = c 更新分支的出现。经过思考，我们给出了避免无限循环的正确版本。

同一个模版的同一种情形，有时存在多种写法。

简单展示了Java, C++, Python中相关二分查找方法(函数)分别对应本文介绍的哪种模版的哪种情形。

拓展阅读
提前溢出
关于求中间值坐标的写法。

最简单的写法是 c = (l + r) / 2，但直接相加会使得 l + r 大于 2^31-1 (2147483647) 时（提前）溢出，例如 l = 1, r = 2^31-1，计算 c 时， l + r = 2^31 (2147483648) 导致溢出。但原本应该有 c = 1073741824，l, r, c都不应该溢出，只是因为 l + r 导致了（提前）溢出。

因此改写成先减后加的形式 c = l + (r - l) / 2。这是最常见的形式。

很多人会用 >> 代替除法，写成 c = l + ((r - l) >> 1) 也是可以的。

值得一提的是JDK中采用的是 c = (l + r) >>> 1的写法。

>>> 是无符号右移运算符(Unsigned right shift operator)，与 >> 的区别在于右移的时不考虑符号位，总是从左侧补0，l + r 不溢出的时候符号位本来就是0，与 >> 效果相同。 l + r 溢出时最高位符号位从0进位成了1，经过 >>> 的移位，最高位又变回了0，这是一种利用位运算的trick，可以参考这里。

需要注意的是若采用此种写法，需要保证 (l + r) 为非负整数。因为若 (l + r) 为负数，经过高位补0后将得到错误的正数。通常情况下，l 与 r 代表下标，不会出现负数情况，但有的题目要在包含正负数的范围内，对这些 「数值」（而非下标） 进行二分查找， l 和 r 表示可能为正也可能为负的「数值」，此时就不用能 >>> 的写法。例如462. 最少移动次数使数组元素相等 II 题就不能采用 >>> 写法。

二分查找趣闻
Java传奇开发人员Joshua Bloch 2006年在Google任职时写过一篇博文Extra, Extra - Read All About It: Nearly All Binary Searches and Mergesorts are Broken，主要讲的是求中间值下标的「提前溢出」问题。Joshua Bloch聊了这么几个事。

他在CMU刚读博的第一堂算法课上，老师Jon Bentley(「编程珠玑」作者，k-d树发明人)让大家写二分查找，结果大部分人的实现都是错误的。

到2006年的时候，Joshua Bloch才知道「编程珠玑」中的二分查找实现存在上述整数溢出的问题，此时距离该书出版已经过去了21年。

直到那时，同样的bug在他实现的JDK的binarySearch里也已经存在了9年之久。就因为中间值下标的计算语句是 int mid =(low + high) / 2; 。

他提出归并排序以及其他一些分治算法都要重新审视是否存在同样的问题。

Joshua Bloch因此怅然良久，发出了一些bug与我们永存，对待代码要有敬畏之心之类的感慨。

※ Extra, Extra即“号外！号外！”，可见当时Joshua Bloch写这篇文章的时候确实是心有戚戚不吐不快。

关于名称
模版一 & 模版二
「模版一」、「模版二」是约定俗成的命名，并不必然与某种确定的模式相绑定。但大部分资料，包括本文所述的「模版一」，都是基于「错位终止」而言的，也就是 while循环结束时一定有 r = l - 1，这一点是所谓「模版一」的标志 ，故以 「错位终止」 强调之。在「模版二」中， while终止时一定有 r = l ，这是「模版二」的标志，故也加上了 「相等终止」 的描述。「错位终止」、「相等终止」是我为了方便行文起的名字，实际上用 「左闭右闭」 来指代「模版一」， 「左闭右开」 来指代「模版二」是目前通用的说法，所谓「闭开」指的是初始时 l 与 r 的取值范围。不过我对「左闭右闭」、「左闭右开」的称呼不太满意，二者的搜索空间其实是一致的，我尝试去理解这个名称的时候，结合网上的一些说法，我想大概是因为「左闭右闭」的取值范围为 [l, r]（其中 r = n - 1, n = nums.length），写起来像表示实数范围的左闭右闭区间（虽然这个区间取值是离散的整数）。而「左闭右开」表示为 [l, n)，表示 初始 r = n，但 c 取不到 n 值。我觉得很没有道理，因为前者的 c 同样取不到 n，而且二者形式上也不统一，你总不能把后者写成 [l, r)，那就更不对了，总之这是个令我感到困惑的称呼。 「左闭右闭」左右界初始取值为 l = 0, r = nums.length - 1，搜索空间表示为 [l, r]，在形式上两边闭，故名。同理，「左闭右开」左右界初始取值 l = 0, r = nums.length，搜索空间表示为 [l, r)，在形式上为左闭右开，故名。我提出的命名主要是想强调while终止时 l 与 r 的位置关系，使用不同模版解决各类二分问题时，我们应当时刻记住 l 与 r 的最终位置关系，「错位」和「相等」这两个词能很好的表达相应的位置关系。

二段性
因为正文内容基于输入数组具有「有序性」的704题介绍，因此对于二分查找更本质的「二段性」概念未在正文中正式的介绍。关于 「二段性」 ，在「实战应用」一节的题解中，你会看到有些题目的数组并不具备有序性，但丝毫不妨碍以二分查找处理。这是因为，只要数组能够根据特定的条件（其实就是「循环不变」）被分为两半，且搜索空间为其中的一半，循环地如此二分下去，直到穷尽原搜索空间，最终必能确定答案（存在与否，及若存在是哪个）。这就是「二段性」，更严谨点说是 「输入序列对于答案可被二分至穷尽」 这一本质特征。最典型的莫过于162. 寻找峰值 ，输入元素大小和顺序是任意的，只需至少存在一个数，其左右两边的数小于它即可。看起来十分反直觉，但仍可通过「循环不变」知道其满足上述本质特征，了解到这一点后就不会觉得有多特别了。另外，关于「二段性」的名字，不知是何人何时开始称呼的，个人感觉值得推敲，「段」字是名词，属于静态描述，而且隐隐约约让人觉得「段」内元素有某些相同的性质，因为它们属于同一段。个人倾向于「可二分性」或略称「二分性」，「分」是动词，属于动态描述，（也许）更能准确地指出「输入序列对于答案可二分至穷尽」这一本质。这当然只是一点愚见，我们还是用行之有年的「二段性」指称之。

实战应用
704. 二分查找
704. 二分查找 (简单)。最基本的「存在性」二分查找问题，即只考察是否存在目标值，而不考虑大于小于等情形。前文已介绍过，使用两个模版中的「相等情形」、「情形1」和「情形3」的任意一份代码，均可解决，此处不再列出。

69. x的平方根
69. x 的平方根 (简单)。按题意，立即看出是「小于等于」情形，即在 [0, x] 范围内的整数中找到一个数 c ，使得 c * c <= x。使用两个模版中的「情形3」即可。在充分理解前面讲解的内容之后，我们仅需记忆两个模版的三个特征即可（这三个特征是三位一体的模版标志），对于模版一，如下：

r 的初始值为搜索空间上界，在本题中为 r = x。

while中为 <= 。

l 与 r 的更新形式，即 l = c + 1, r = c - 1。

对于模版二，如下：

r 的初始值为搜索空间上界 + 1，在本题中为 r = x + 1。

while中为 < 。

l 与 r 的更新形式，即 l = c + 1, r = c。

对本题来说，从简便性来看，两个模版没有区别，剩下要做的只有 if 中的条件需要略加思考，因为是「小于等于」情形，那么 if 中的判断能够将 l 或 r 的左侧都断言为「小于等于」即可，立刻写出 if(c * c <= x) l = c + 1，这样就可以使得 l 左侧满足 c * c <= x，若用模版一，返回 l - 1 (或 r)，若用模版二，返回 l - 1 (或r - 1)。需要注意的是， c * c 可能溢出，需转型为long。


// 模版一「一般」情形3: 小于等于
class Solution {
    public int mySqrt(int x) {
        int l = 0, r = x;
        while(l <= r){
            int c = l + (r - l) / 2;
            if((long) c * c <= x) l = c + 1; // #1 更新后l左侧「必」小于等于x
            else r = c - 1; // #2 更新后r右侧「必」大于x
        }
        return r; 
    }
}
使用模版二时，还需注意，因为 r = x + 1，若x = 2^31 - 1，则 r 刚好溢出，因此对于这个情形需要特别处理，见如下。从这一点来看，本题用模版一更好。


// 模版二「一般」情形3: 小于等于
class Solution {
    public int mySqrt(int x) {
        int l = 0, r = x == Integer.MAX_VALUE ? x : x + 1; // r的取值需要稍微注意
        while(l < r){
            int c = l + (r - l) / 2;
            if((long) c * c <= x) l = c + 1; // #1 更新后l及其左侧元素「必」小于等于x
            else r = c; // #2 更新后r右侧「必」大于x
        }
        return r - 1; 
    }
}
374. 猜数字大小
374. 猜数字大小(简单)。仍旧是最基本的「存在性」题型。采用两个模版的「相等返回」、「情形1」或「情形3」均可。这里只列出模版一的「相等返回」和模版二的「情形1」供参考，其他的都非常容易写出。需要强调的是，虽有多种不同写法，但对「是否存在」的基本题型，选用「相等返回」写法为佳，其次，因为「模版二」r 的初始值需考虑溢出特例，从这一点上看，选用「模版一」为佳（除非数据范围不会导致 r 初始时溢出）。


// 模版一「相等返回」
public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int l = 1, r = n;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(guess(c) == 0) return c;
            else if(guess(c) == 1) l = c + 1;
            else r = c - 1;
        }
        return -1; // 因为 c 必存在，这条语句不会执行
    }
}
使用模版二时，本题无需令 r = n + 1，只有一个元素时正好返回正确答案，被选数字为最大的那个数时，也正好返回最大数。


// 模版二「情形1」：大于等于
public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int l = 1, r = n;
        while(l < r){
            int c = l + (r - l) / 2;
            if(guess(c) == 1) l = c + 1;
            else r = c;
        }
        return r; // 因为 c 必存在，无需判断
    }
}
33. 搜索旋转排序数组
33. 搜索旋转排序数组 (中等)。这一题相比典型的有序数组二分，输入数组并不整体有序，而是分为两个有序的部分。你可能在其他地方有看到过这么一种说法，即二分查找的前提只需要输入数组具有「二段性」而不要求整体的「有序性」，所谓「二段性」即每一次循环查找，均可排除掉一半的答案（或者说将搜索空间缩小一半），其实也就是 l 或者 r 的更新。这一题就很好地体现了这一说法。根据题目要求，这也是一个基本的「存在性」的问题，因此我们采用「相等返回」写法。if(nums[c] == target) return c 的判断分支自不必说，重点来说两个不等分支的写法。如果是有序数组，对于nums[c]，只需要与target对比即可知道应该往哪个方向收缩搜索空间（更新 l 或 r），但本题不行，比如nums[c] < target，则targe的下标t即有可能在 c 之前，也有可能在 c 之后。实际上我们仅需先行判断 c 属于哪个部分，就可以通过「循环不变」的断言来更新 l 或 r ，从而「一半一半」地压缩搜索空间了。

我们通过下图来理解，c 落入哪个空间可以通过用nums[c]与整个数组的首尾元素比较得出。nums[0]是第一段递增序列的起始元素，nums[n - 1]是第二段递增序列的末尾元素(n 为nums长度)。当 c 落入第一段中(nums[c] >= nums[0])，按照习惯，我们先更新 l，即寻找使得target「必」在 c 右侧的条件（这就是我们主动寻找的「循环不变」），不难写出该条件为 target > nums[c] || target < nums[0]，注意若只写第一个条件，会漏掉target在第二个递增区间的情况，于是更新 l = c + 1。否则「必」在左侧，更新 r = c - 1。类似地，如果落入第二个递增区间 (nums[c] <= nums[n - 1])，仍旧先更新 l，使得target「必」在c 右侧的条件为 nums[c] < target <= nums[n - 1] (这也是我们主动寻找的「循环不变」)，于是更新 l = c + 1，否则更新 r = c - 1。



先行判断 c 落于哪个区间会产生两个大的if-else分支，每个分支中依据「循环不变」来更新 l 和 r 与常规题目相同，很容易写出如下「模版一」的「相等返回」情形代码。处理更多的题目之后，你可能会发现「循环不变」的指导变得越来越自然，你甚至不会特别去提醒自己这个原则，而是自然地使用这个原则。


// 「模版一」相等返回
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length, l = 0, r = n - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] == target) return c;
            if(nums[c] >= nums[0]){ // c落入第一个递增区间
                if(target > nums[c] || target < nums[0]) l = c + 1; // 在c右侧
                else r = c - 1; // 在c左侧
            }
            else { // c 落入第二个递增区间
                if(target > nums[c] && target <= nums[n - 1]) l = c + 1; // 在c右侧
                else r = c - 1; // 在c左侧
            }
        }
        return -1;
    }
}
前面我们强调总是按习惯先更新 l，如果你的习惯是先更新 r，那么你应该会写成如下形式。先更新哪一个导致条件有所区别，但这不要紧，只要我们遵循「循环不变」，正确更新 l 和 r 即可。


// 「模版一」相等返回，先更新 r
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length, l = 0, r = n - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] == target) return c;
            if(nums[c] >= nums[0]){ // c落入第一个递增区间
                if(target >= nums[0] && target < nums[c]) r = c - 1; //在c左侧
                else l = c + 1; // 在c右侧
            }
            else { // c 落入第二个递增区间
                if(target < nums[c] || target > nums[n - 1]) r = c - 1; // 在c左侧
                else l = c + 1; // 在c右侧
            }
        }
        return -1;
    }
}
「存在性」问题用情形1（大于等于）或情形3（小于等于）也是可以解决的，这里选用「模版二」的「情形1」来展示不同的解法。不过我必须再次声明，对于「存在性」问题，「相等返回」的写法是首选。这里只不过是想表现出如果全面理解了本文，你可以随机采用一种能够解决问题的「情形」写法，而不再存在该背哪个模版，或该用哪个模版的问题了。


// 「模版二」情形1
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length, l = 0, r = n;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] >= nums[0]){ // c落入第一个递增区间
                if(target < nums[0] || target > nums[c]) l = c + 1; // target不在左侧
                else r = c; // target下标为r或在r右侧
            }
            else { // c 落入第二个递增区间
                if(target > nums[c] && target <= nums[n - 1]) l = c + 1; // target不在左侧
                else r = c; // target下标为r或在r右侧
            }
        }
        return (r != n && nums[r] == target) ? r : -1;
    }
}
153. 寻找旋转排序数组中的最小值
153. 寻找旋转排序数组中的最小值 (中等)。本题是33. 搜索旋转排序数组的变形，与之不同的是，这里没有了显式的target，不过这完全不要紧（反而更简单），只要我们找到更新 l 和 r 的条件即可，回想我们在题33中画的图，要找的数字是第二个递增区间的第一个元素的下标，因此只需要判断 c 在哪一个区间，通过该信息来更新 l 和 r 来逼近目标下标。若在第一个区间，则应当更新 l，排除左侧的可能性，若在第二个区间，则应当更新 r，排除右侧的可能性。本题显然不属于「存在性」类型，所以应当采用「相等返回」之外的写法。下面给出「模版一」的写法。需要注意的是，从第一个if更新语句可以看到，我们是以一定存在两个区间为前提来处理的，因此当nums「旋转」回初始状态或只有一个数字时，要以一条特判处理之。


// 模版一
class Solution {
    public int findMin(int[] nums) {
        int n = nums.length, l = 0, r = n - 1;
        if(nums[0] <= nums[n - 1]) return nums[0]; // 原数组情形或只有一个数字
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] >= nums[0]) l = c + 1; // 排除l左侧
            else r = c - 1; 
        }
        return nums[l]; // l = r + 1，返回nums[r + 1]也可以
    }
}
你当然也可以用「模版二」解决。


// 模版二
class Solution {
    public int findMin(int[] nums) {
        int n = nums.length, l = 0, r = n;
        if(nums[0] <= nums[n - 1]) return nums[0]; // 原数组情形或只有一个数字
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] >= nums[0]) l = c + 1; // 排除l左侧
            else r = c;
        }
        return nums[l]; // l = r，返回nums[r]也可以
    }
}
154. 寻找旋转排序数组中的最小值 II
154. 寻找旋转排序数组中的最小值 II (困难)。本题是153. 寻找旋转排序数组中的最小值 的变形，与153题的不同处在与元素大小可以相等。因此我们无法通过nums[c] 与 nums[0] 或与 nums[n - 1]的比较来确定得更新 l 和 r，这一点很容易通过下图看出来，当c位于如下两侧的时候nums[c]相等，如果是左边的情形，应该更新 l，如果是右边的情形，应该更新 r，但现在无法确定了。总之这个特点使得我们没法简单套用模版，但不要紧，只要找到「循环不变」关系即可。



先罗列容易看出的事实：

nums[0] >= nums[n - 1]，如果nums[0] < nums[n - 1]，说明此数组经过旋转回到了未旋转时的状态，即单调状态。

最小值左右侧元素都必大于等于该元素。

从第2点来看，我们至少有这两个循环不变关系，nums[c] > nums[n - 1]，则 l = c + 1，nums[c] < nums[n - 1], r = c。进入这两个分支，我们能够将搜索空间减小一半。r 的更新写成 r = c 是因为当 c 恰好是最小值下标且 nums[c] < nums[n - 1]时，若 r = c - 1，我们将会跳过最小值，不便于返回，因此写成类似「模版二」的形式，使得查找结束时 r 为最小值下标（l = r，返回nums[l]也一样）。现在还差一种情况，即 nums[c] == nums[n - 1]，如前所述，此种情形我们无法做到减小一半空间，但必须更新 l 或 r 使得我们总是能够缩小搜索空间来逼近目标，比如可以收缩一位，l++ 或者 r--。尝试寻找这个分支的「循环不变」关系。经过仔细思考，我们发现对于nums[c] == nums[n - 1]，无论是 l++ 还是 r-- 均不可行，问题还是出在元素可以相等上。例如通过前两个分支，此时 c 恰好是最小值下标。而下一次循环有可能通过该分支前进(l++)或后退(r--)一位而错过该正确下标。例如nums = {2,1,2,2}，第一次进入while使得r更新为 r = c = 1，恰好是最小值下标，下一次进入while时 nums[c] = nums[0] = 3 = nums[n - 1] = 3，无论是l++还是r--，都会错过最小值。调整分支的条件的一个方向是，不再与固定的nums[n - 1]比较，而是与nums[r]和nums[l]比较，这么做的道理在于nums[l]始终为第一个单调区间的最小值，nums[r]始终保持为第二个单调区间的最大值，利用这个特点，可以维持「循环不变」，即前两个分支变为：


if(nums[c] > nums[r]) l = c + 1; // 最小值不在更新后的l左侧
else if(nums[c] < nums[l]) r = c; // 最小值不再更新后的r的右侧
我们知道一定有 nums[l] >= nums[r]，所以第三个分支仅剩下nums[c] == nums[l] == nums[r]这一种可能，其循环不变关系需要仔细推敲。因为nums[c] == nums[r]，如果此时 c == r，说明 l == c == r，即这是最后一次更新，nums[l] == nums[r]就是最小值。如果c < r，说明nums[c]是比nums[r]更靠左的可能的最小值，因此可以不用考虑nums[r]，也就是说，这个分支可以用来更新r，即 r--，且不会出现我们前面所分析的错过最小值的情况。至此我们得到了完整的代码。同样地，我们可以加一个特判用以对旋转回初始状态（且最后一个元素大于第一个元素）或只有一个数字时做快速地判断返回，实际上不用这个特判也是可以的，因为如果是未旋转状态，那么会一直执行 r--，直到 l = r = 0，此时返回nums[l]恰好是正确的，nums只有一个元素的情况也同理。还需要注意的是，虽然看起来像「模版二」，但 r 的初始值为 r = n - 1，这是因为 if 判断中有nums[r]，r = n 时越界。


class Solution {
    public int findMin(int[] nums) {
        int n = nums.length, l = 0, r = n - 1;
        if(nums[0] < nums[n - 1] || n == 1) return nums[0]; // 旋转回初始状态（且最后一个元素大于第一个元素）或只有一个数字，此行可省略
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] > nums[r]) l = c + 1; // 最小值不在更新后的l左侧
            else if(nums[c] < nums[l]) r = c; // 最小值不再更新后的r的右侧
            else r--; 
        }
        return nums[l]; 
    }
}
81. 搜索旋转排序数组 II
81. 搜索旋转排序数组 II (中等)。类似于153和154题的关系，本题是33题的进阶，区别在于元素可重复。有了154题的经验，我们可以写出如下代码。首先是判断nums[c]位于哪个区间时，不与固定的首尾元素比较，而是与当前搜索空间的上下界比较，即#1，#4两处。#1分支说明c在区间一中，通过#2，#3判断target在c的哪一侧，#5和#6同理。#1和#4之外的情形，仅剩 nums[c] == nums[l] == nums[r]这一种可能，此时将nums[c]与target做比较，可判断target在哪个区间，这时候由于无法确定nums[c]在哪个区间，因此不能通过c来更新 l 或 r，但可以逐位移动。


class Solution {
    public boolean search(int[] nums, int target) {
        int n = nums.length, l = 0, r = n - 1;
        if(target == nums[0] || target == nums[n - 1]) return true;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] == target) return true;
            if(nums[c] > nums[r]){ //  #1 c必在区间一
                if(nums[c] < target || target < nums[0]) l = c + 1; // #2 target在c右侧
                else r = c - 1; // #3 target在c左侧
            }
            else if(nums[c] < nums[l]){ // #4 c必在区间二
                if(nums[c] < target && target < nums[0]) l = c + 1; // #5 target在c右侧
                else r = c - 1; // #6 target在c左侧
            }
            else{ // #7 nums[c] == nums[l] == nums[r]
                if(nums[c] < target) l++; // #8 target必在区间一
                else r--; // #9 nums[c] > target，target必在区间二
            }
        }
        return false;
    }
}
278. 第一个错误的版本
278. 第一个错误的版本 (简单)。立刻看出是「大于等于」情形，且一定有解，返回时无需判断。!isBadVersion(c) 就相当于 nums[c] < target，仅此而已。


// 模版一大于等于情形
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int l = 1, r = n;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(!isBadVersion(c)) l = c + 1; // 必不在更新后的l左侧
            else r = c - 1;
        }
        return l;
    }
}

// 模版二大于等于情形，r 初始时不需要设置为n + 1，因为不管是n = 1还是错误版本再最后，都正好能正确返回
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int l = 1, r = n;
        while(l < r){
            int c = l + (r - l) / 2;
            if(!isBadVersion(c)) l = c + 1; // 必不在更新后的l左侧
            else r = c;
        }
        return l;
    }
}
162. 寻找峰值
162. 寻找峰值 (中等)。要求山峰值严格大于左右，立刻感觉到这是为「模版二」量身定制的场景。因为模版二循环终止时 l = r，若「循环不变」为 l 左侧一位小于nums[l]，r 右侧一位小于nums[r]，最终 l = r，那么l (即 r) 一定是顶峰。此循环不变关系很容易找到，即 nums[c] 与 nums[c + 1]比较，nums[c] < nums[c + 1]则更新 l = c + 1，即有 l 左侧一位小于nums[l]，另外就是nums[c] > nums[c + 1]时更新 r = c，即有 r 右侧一位小于 nums[r]。题目已声明不存在相邻元素相等的情况，因此这两个条件就足够完备了。如下为「模版二」写法，因为只有一个元素或山峰在最右侧时均可正确返回结果，因此 r 初始不必为 nums.length。另外也容易看出 c + 1 不可能越界。这一题再次向我们展示了能够应用二分查找的问题，其本质是具有「二段性」而非「有序性」。而所谓「二段性」的本质又回归到「循环不变」，在「循环不变」中不断压缩搜索空间，直到压缩出明确的结果，然后以「循环不变」的事实宣告这个结果的性质。


// 模版二
class Solution {
    public int findPeakElement(int[] nums) {
        int l = 0, r = nums.length - 1;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] < nums[c + 1]) l = c + 1; // c到c+1上升
            else r = c; // c到c+1下降
        }
        return r; // l或r都可以
    }
}
虽然这题有强烈的「模版二」特点，但略加思考，因为题目声明了相邻元素不会相等，那么「大于」、「小于」情形也有可能能够解决此题。我们尝试分析「模版一」的「大于」写法。如下，l 更新后 nums[l] > nums[l - 1]是显然的。若 r 更新为 r = c - 1，是因为 nums[c] > nums[c + 1]，其实就是 nums[r + 1] > nums[r + 2]。而循环终止时 l = r + 1，因此nums[l]刚好就是山峰。所以此写法也是可行的，与前一种实现不同的是这里 c + 1可能导致nums[c + 1]越界，仅在l = r = nums.length - 1时发生，此时可直接返回nums.length - 1。


// 模版一「大于」情形
class Solution {
    public int findPeakElement(int[] nums) {
        int l = 0, r = nums.length - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(c == nums.length - 1) return c;
            if(nums[c] < nums[c + 1]) l = c + 1; // 更新后 l 比左邻大
            else r = c - 1; // nums[c] > nums[c + 1]，对于更新后的 r, nums[r+1] > nums[r+2]
        }
        return l; 
    }
}
34. 在排序数组中查找元素的第一个和最后一个位置
34. 在排序数组中查找元素的第一个和最后一个位置 (中等)。根据题意，找第一个位置就是「大于等于」情形，最后一个位置就是「小于等于情形」。用相应的情形写法分别找到即可，下面展示的代码中，用「模版一」的「大于等于」写法寻找元素的第一个位置，用「模版二」的「小于等于」寻找元素的最后一个位置。


// 模版一（找首位） + 模版二（找末位）
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int n = nums.length, l = 0, r = n - 1;
        int[] ans = new int[2];
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1;
            else r = c - 1;
        }
        ans[0] = (l < n && nums[l] == target) ? l : - 1;
        l = 0;
        r = n;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] <= target) l = c + 1;
            else r = c;
        }
        ans[1] = (l > 0 && nums[l - 1] == target) ? l - 1 : -1;
        return ans;
    }
}
你当然也可以用模版一找末位，二用模版二找首位，用法是自由的，代码细节不再赘言。


// 模版二（找首位） + 模版一（找末位）
// 小于等于 && 大于等于
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int n = nums.length, l = 0, r = n - 1;
        int[] ans = new int[2];
        while(l < r){ 
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1;
            else r = c;
        }
        ans[0] = (l < n && nums[l] == target) ? l : -1;
        l = 0;
        r = n - 1;
        while(l <= r){ 
            int c = l + (r - l) / 2;
            if(nums[c] <= target) l = c + 1;
            else r = c - 1;
        }
        ans[1] = (r >= 0 && nums[r] == target) ? r : -1;
        return ans;
    }
}
35. 搜索插入位置
35. 搜索插入位置 (简单)。标准的「大于等于」情形。


// 模版一
class Solution {
    public int searchInsert(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1;
            else r = c - 1;
        }
        return l;
    }
}

// 模版二
class Solution {
    public int searchInsert(int[] nums, int target) {
        int l = 0, r = nums.length;
        while(l < r){
            int c = l + (r - l) / 2;
            if(nums[c] < target) l = c + 1;
            else r = c;
        }
        return l;
    }
}
74. 搜索二维矩阵
74. 搜索二维矩阵 (中等)。只需将坐标从二维映射到一维，即转变为标准的「相等返回」情形。


// 模版一：相等返回
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length, n = matrix[0].length, l = 0, r = m * n - 1;
        while(l <= r){
            int c = l + (r - l) / 2;
            int cur = matrix[c / n][c % n];
            if(cur == target) return true;
            else if(cur < target) l = c + 1;
            else r = c - 1; 
        }
        return false;
    }
}

// 模版二：相等返回
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length, n = matrix[0].length, l = 0, r = m * n;
        while(l < r){
            int c = l + (r - l) / 2;
            int cur = matrix[c / n][c % n];
            if(cur == target) return true;
            else if(cur < target) l = c + 1;
            else r = c; 
        }
        return false;
    }
}
658. 找到 K 个最接近的元素
658. 找到 K 个最接近的元素 (中等)。一个比较容易想到的做法是先找到 x 所在位置idx，然后要求的 k 个数一定位于从 x 往前 k 个数字，往后 k 个数字这个范围之间。由于要求的k个数字是连续的，自然想到滑动窗口。具体做法如下：

由于x可能不存在，因此用「小于等于」或「大于等于」 情形的二分查找找到目标下标idx，这里我们选用「小于等于」。

窗口滑动范围为 [max(0, idx - k + 1), min(n - 1, idx + k)]，该范围内最多 2k - 1个数字，注意max和min的作用是防止前面或后面的数不足。

计算第一个窗口的delta，delta指的是窗口内所有数字与x的差的绝对值之和。记录此时的窗界，作为具有最小delta窗的窗界。

逐位滑动窗口，计算进入窗口和离开窗口的数字与x的差值的绝对值，分别为inc和dec，若dec > inc，说明delta减少了，更新具有最小delta窗的窗界。

当滑动结束时，得到的具有最小delta的窗口内的数字即为所求的k个值。

此做法思路简单，代码如下。一开始有两个特判，分别处理x小于等于第一个数和x大于等于最后一个数的情形，第一种情形直接从第一个数开始取k个，第二种直接从最后一个数往前取k个。


class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        int n = arr.length, l = 0, r = n - 1;
        if(x <= arr[0]) return copy(arr, 0, k - 1); // 特判，从第一个数开始取k个
        else if(x >= arr[n - 1]) return copy(arr, n - k, n - 1); // 特判，从最后一个数往前取k个
        while(l <= r){
            int c = l + (r - l) / 2;
            if(arr[c] <= x) l = c + 1;
            else r = c - 1;
        }
        int idx = r; // 取得「小于等于」x 的下标
        l = Math.max(0, idx - k + 1); // 滑窗左界
        r = l; // 滑窗右界
        n = Math.min(n - 1, idx + k); // 滑动上界
        int minDelta = 0; // 窗内元素与x做差的绝对值之和
        for(; r < l + k; r++){ // 第一个窗口
            minDelta += Math.abs(arr[r] - x);
        }
        int minl = l, minr = r - 1; // 第一个窗的左右界
        while(r <= n){ // 滑动
            int inc = Math.abs(arr[r] - x);
            int dec = Math.abs(arr[l] - x);
            if(dec > inc){ // 更新使得minDelta更小的窗界
                minl++;
                minr++;
            }
            l++;
            r++;
        }
        return copy(arr, minl, minr);
    }

    private List<Integer> copy(int[] arr, int i, int j){
        List<Integer> res = new ArrayList<>();
        for(; i <= j; i++) res.add(arr[i]);
        return res;
    }
}
相比上述二分查找结合滑窗的做法，本题还有一种不太直接，但更为纯粹，效率也更高的二分查找做法。如下图，求数组中所有数字与x的差值的绝对值后，这些值形成两段单调区间，先下降后上升。存在两种特例，当x小于等于首个数字时只有一段单调非递减区间，当x大于等于最后一个数字时只有一段单调非递增区间，不过这不影响我们的分析。显然要求返回的k个数字是从最底部数字开始向上找位置最低的k个数字。如果我们能找到这个数字，那么从它开始的k个数字即为所求。首先，这k个数字中的首个的下标 l 一定落在[0, arr.length - k]区间。思考如何在[0, arr.length - k]区间上用二分查找寻找 l 时，应当首先寻找关于它的「循环不变」关系，即该数字左侧/右侧数字应满足的约束。回想题目要求并结合下图，绿点表示要所求的k (k = 8)个元素，点的高度表示对应的 |arr[i] - x| ，(1), (2)为同一数组的选择，表现稍后的「循环不变」关系1，其中(1)为错误选择，(2)为正确选择。(3), (4)为另一数组的选择，表现稍后的「循环不变」关系2，其中(3)为错误选择，(4)为正确选择。不难得出这个关系应为：1. arr[l] 左侧数字与x的差的绝对值，要大于arr[l + k - 1]与x的差的绝对值 (结合下图的(1), (2)观察); 2. arr[l]本身与x的差的绝对值，要小于等于arr[l + k - 1]与x的差的绝对值（结合下图的(3), (4)观察）。这具有强烈的「模版二」味道。



根据上述分析，我们采用「模版二」写出如下代码，初始的 r 不必为 arr.length - k + 1，因为当 r 不更新时，说明 x 大于或等于最大值，最终得到的结果是正确的。反而如果 r = arr.length - k，那么之后的arr[c + k]可能越界。此外需要小心处理的地方仅有一处，即 if 中的条件。l 更新后，c 即为 l 的左侧，其左侧数字与x的差的绝对值即为 x - arr[c]，之所以不需要取绝对值是因为最终 l 必在最底部的左侧（或当x小于等于首个数字时 l 为最底部的下标）。又因为 c = l - 1，因此arr[l + k - 1] - x即此时的arr[c + k]，于是写出if (x - arr[c] > arr[c + k] - x)。


class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        int l = 0, r = arr.length - k;
        List<Integer> res = new ArrayList<>();
        while(l < r){
            int c = l + (r - l) / 2;
            if(x - arr[c] > arr[c + k] - x) l = c + 1;
            else r = c;
        } // 循环结束后 l = r为所求k个元素的第一个的下标。
        for(int i = 0; i < k; i++){
            res.add(arr[i + r]);
        }
        return res;
    }
}
29. 两数相除
29. 两数相除 (中等)。这是一道应用了二分思想但解题过程并不能套用模版的题。在这里也详细展示求解过程。由于题目要求不能使用乘法、除法以及求余，因此考虑用加法代替乘法。对于 a / b, a、b都是整数，为了缩小讨论范围，假设a、b都是正数，那么商的范围为[0, a]，当a < b或b = 0(无意义)时为0。可以通过不断倍增b并将倍增结果与a比较来找到商，这实际上是一个二分搜索的过程。关键代码如下(a / b = c)。应当注意，b在倍增过程中，若超过最大值的一半，那么b + b会因为溢出得到负数，此时 <= a的判断将导致错误的结果，因此在while条件中要使得b <= Integer.MAX_VALUE / 2。例如a = Integer.MAX_VALUE, b = 1时，b会倍增到1073741824 > Integer.MAX_VALUE / 2 = 1073741823，不满足上述条件跳出循环（短路判断）。


int c = 1; // 商
while(b <= Integer.MAX_VALUE >> 1 && b + b <= a){
  b += b; // 除数倍增
  c += c; // 商相应倍增
}
现在我们从一个例子出发，逐步完善求解过程。例如求解a = 100, b = 7。按照前述while，得到b, c的变化(b = 14, c = 2), (b = 28, c = 4), (b = 56, c = 8)，之后由于b + b = 112 > a，跳出循环。至此得到了a中56的部分被7除的结果，a剩余的部分100 - 56 = 44 > 7，因此仍然可继续被7除。由于在有剩余的情况下余下部分的大小需要与b进行比较，因此用d = b来表示除数的倍增变化，用ans来累计商。


public int divide(int a, int b) {
    int ans = 0; // 最终的商
    while(a >= b) {
        int d = b, c = 1; // 当前倍增的部分商
        while(d <= Integer.MAX_VALUE >> 1 && d + d <= a) {
            d += d; // 除数倍增
            c += c; // 当前商倍增
        } 
        a -= d; // a剩余部分
        ans += c; // 累计商
    }
    return ans;
}
本题的求解框架如上，但这是基于a、b均为正整数的情况，当a、b不同号时，一个自然的想法是按正整数求解，返回结果时再取反即可。按照这个想法，现在来考虑a、b的符号以及edge cases。a、b的范围均为[-2^31, 2^31 - 1]，为方便，定义MIN = -2^31, MAX = 2^31 - 1。可以看到MIN的绝对值比MAX更大，当a = MIN时，对a取反会导致溢出。因此我们反其道而行之，按a、b都为负数处理，这样就可以覆盖所有a、b取值的情形。将前述假设a、b均为正数的代码修正为假设a、b均为负数的版本。另外对于第二个while中的(d + d <= a)，有经验的话不难察觉到d + d的写法可能导致加法溢出，因此改写为d <= a - d。但由于第一个条件已经避免了d + d溢出的情形，因此无需改写。

题目已经声明b != 0，因此无需考虑这个edge case。唯一需要处理的edge case是a = -2^31, b = -1，此时会溢出，按题目要求应该返回MAX。至此我们可以写出完整代码。


public int divide(int a, int b) {
    int MIN = Integer.MIN_VALUE, MAX = Integer.MAX_VALUE, MIN_LIMIT = MIN >> 1; // -1073741824
    if(a == MIN && b == -1) return MAX; // 特判
    boolean isPos = (a < 0 && b > 0) || (a > 0 && b < 0) ? false : true;
    if(a > 0) a = -a;
    if(b > 0) b = -b;
    int ans = 0; // 最终的商
    while(a <= b) {
        int d = b, c = 1; // d为当前除数，c为当前商
        while(d >= MIN_LIMIT && d + d >= a) { // 通过第一个条件防止d + d溢出
            d += d; // 当前除数倍增，也可以用 d <<= 1;
            c += c; // 当前商倍增，也可以用d <<= 1;
        } 
        a -= d; // a剩余部分
        ans += c; // 累计当前商
    }
    return isPos ? ans : -ans;
}
有意思的是这种做法的时间复杂度为O((logc)^2)，而不是典型的对数复杂度。可以这么求解，从1开始倍增直到c的过程中，内层while内的语句执行次数由此式得到：log(c - x) + log(x - y) + log(y - z)...。x, y, z表示每次剩余的部分，且每次剩余的部分均小于当前部分的一半，最多共有logc项。可以看到虽然为对数平方阶，但随着项数增加，log中的真数快速下降，因此实际效率要好得多。也可以粗略地通过下式观察得出。

log(c - x) + log(x - y) + log(y - z)... < logc + log(c/2)+ log(c/4)... = logc * logc - log2 - log4...

875. 爱吃香蕉的珂珂
875. 爱吃香蕉的珂珂 (中等)。二分变形题，需要通过数值映射来找到二分查找的对象。首先遍历一遍所有香蕉堆，找到最大的那堆，假设最多有max根香蕉。那么，k一定是{1,2,3,...,max}中的某个数。现在来做一个映射，对上面的序列中的每个数，求出k对应的耗费时间，即以速度k吃完所有香蕉，需要花费的时间，得到数组{h1,h2,h3,...hx}，于是问题转换为找到小于等于 h 的值的下标。采用「小于等于」情形的写法。需要注意的时，用于与 h 做比较的 hx，需要在每一次得到一个新 k 值后以一次遍历求出，hx > h 说明耗时较h多，需要加快速度，于是 l = k + 1。l 的左侧为耗时多于 h 的速度，因此最终返回 l。


// 模版一
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int max = 0;
        for(int pile : piles) { // 确定最大香蕉堆的香蕉根数
            max = Math.max(max, pile); 
        }
        int l = 1, r = max; 
        while(l <= r){ 
            int hx = 0;
            int k = l + (r - l) / 2;
            for(int pile : piles) { // 求k对应的时间
                hx += (pile - 1) / k + 1; // 向上取整写法
            }
            if(hx > h) l = k + 1; // 耗时多于h，要加快速度
            else r = k - 1; // 耗时小于等于h，降低速度
        }
        return l; 
    }
}
模版二写法如下。


// 模版二
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int max = 0;
        for(int pile : piles) { // 确定最大香蕉堆的香蕉根数
            max = Math.max(max, pile); 
        }
        int l = 1, r = max; 
        while(l < r){ 
            int hx = 0;
            int k = l + (r - l) / 2;
            for(int pile : piles) { // 求k对应的时间
                hx += (pile - 1) / k + 1; // 向上取整写法
            }
            if(hx > h) l = k + 1; // 耗时多于h，要加快速度
            else r = k; // 耗时小于等于h，降低速度
        }
        return l; 
    }
}
668. 乘法表中第k小的数
668. 乘法表中第k小的数 (困难)。两个大步骤。

看出是二分问题（需要一点经验）。

找「循环不变」，正向提取出左右界的更新条件。再按图索骥找能支持我们写出该条件的量。

具体分析：

一共有m * n个数，搜索空间为[1, m * n]，初始 l = 1, r = m * n。「第k大」的数在此搜索空间中。

取得每次二分要考察的数 c = (l + r) / 2 之后（不一定在矩阵上），要使得「循环不变」为（按「模版一」写）：

l = c + 1，使得 l 更新后，必满足 「少于k个数」 小于c

r = c - 1，使得 r 更新后，必满足 「大于等于k个数小于c」。

最终 l 就是「第k大」的数。

所以这其实是二分查找的 「小于」情形 。为了写出更新 l 和 r 的条件，需反推要如何知道对于c，矩阵中有多少个小于它的数。

写出几行矩阵，观察一下，可以有如下分析。

c 在第c/n行，前面的行中所有数均小于c。

从c/n行开始，一直到m行，都可能存在小于c的数，累计即可。第k行小于c的数的个数为c/k。

我们分别用两个模版写出来。求count的时候有个小小的优化，就是 c >= i条件，如果c < i，那从这行开始往后的行就不存在小于c的数了，就不用累计了。

【模版一「小于」情形】


class Solution {
    public int findKthNumber(int m, int n, int k) {
        int l = 1, r = m * n;
        while(l <= r){
            int c = (l + r) >>> 1;
            int count = (c / n) * n;
            for(int i = c / n + 1; i <= m && c >= i; i++){
                count += c / i;
            }
            if(count < k) l = c + 1;
            else r = c - 1;
        }
        return l;
    }
}
【模版二「小于」情形】


class Solution {
    public int findKthNumber(int m, int n, int k) {
        int l = 1, r = m * n;
        while(l < r){
            int c = (l + r) >>> 1;
            int count = (c / n) * n;
            for(int i = c / n + 1; i <= m && c >= i; i++){
                count += c / i;
            }
            if(count < k) l = c + 1;
            else r = c;
        }
        return l;
    }
}
462. 最少移动次数使数组元素相等 II
462. 最少移动次数使数组元素相等 II (中等)。本题其实可以看作是162. 寻找峰值 的拓展题，思想一致(虽然一个找峰，一个找谷)，但本题稍难。如果你还没做过162，建议先做162再做本题。下面是解题时间。（本题另有「中位数」解法，可基于快速排序思想实现平均 O(n)O(n) 的时间复杂度，该解法已更新到十大排序从入门到入赘 一文的「实战应用」中。）

看出是二分问题，在某确定范围内搜索某必存在目标值（需要一点经验）。

搜索空间为[min, max]，min，max分别是nums中最小和最大数。

找「循环不变」关系，我假设你已经做完162题了，那么「循环不变」关系就不难看出蕴含于 c 和 c + 1对应的差分总值的大小关系中。 c = l + (r - l) / 2，差分总值是nums中所有数对 c 求绝对值的和。

因为我们求的目标值 t 一定使得 t 对于nums的差分总值最小（可能存在多个这样的值，但不影响）。如果从min到max的所有值都求出对应的差分总值，画出来就是一条U型的先降后升曲线。那么：


int count = diffCount(nums, c); // c的差分总值
int countNext = diffCount(nums, c + 1); // c+1的差分总值
// 当 countNext < count 时，更新 l = c + 1，此时的「循环不变」关系是：
// l 更新后，其左侧元素的差分总值一定更大。
// 当 countNext >= count时，更新 r = c，此时的「循环不变」关系是：
// r 更新后，r小于等于其右侧元素的差分总值
if(countNext < count) l = c + 1; // 
else r = c;
不难看出，U型「谷底」必为最终的 r ，返回它的差分总值即可。

强调一点，建议像162题那样画图分析（此处不再画图），这样你会看出来选用「模版二」的「小于」情形是最合适的。


// 二分查找 「模版二」的「小于」情形
class Solution {
    public int minMoves2(int[] nums) {
        int l = nums[0], r = nums[0], ans = 0;
        for(int num : nums){
            l = Math.min(l, num);
            r = Math.max(r, num);
        }
        while(l < r){
            int c = l + (r - l) / 2;
            int count = diffCount(nums, c), countNext = diffCount(nums, c + 1);
            if(countNext < count) l = c + 1; // 
            else {
                r = c;
                ans = count;
            }
        }
        return ans;
    }
    private int diffCount(int[] nums, int target){
        int count = 0;
        for(int num : nums){
            count += Math.abs(num - target);
            // count += num > target ? num - target : target - num; 
        }
        return count;
    }
}
时间复杂度：二分 O(logn)O(logn)，累计差分总值 O(n)O(n)，整体 O(nlogn)O(nlogn)。

空间复杂度：O(1)O(1)。

实际上平均时间复杂度为 O(n)O(n) 的快速选择的解法也是「二分查找」。详情还是请移步「十大排序从入门到入赘」一文相关题解中。

436. 寻找右区间
436. 寻找右区间 (中等)。很容易看出如下做法，对所有区间的左界排序，遍历intervals，对每一个右界，用「二分查找」的「大于等于」情形，在排序的左界中寻找「大于等于」该右界的左界，将其所属区间在intervals中的下标返回到结果中。

可以用一维数组保存并排序左界，用map来保存左界和其所属区间在intervals中的下标，以便二分查找到该左界时相应下标。我们也可以不用map，而是用二维数组int[][] lefts[intervals.length][2]来保存左界。具体过程。

首先遍历intervals，将第 i 个区间的左界值写入 lefts[i][0] 中，即 lefts[i][0] = intervals[i][0]; ，同时记录此时的下标 lefts[i][1] = i。

用Arrays.sort对 lefts 排序（当然也可以自己写排序方法）。

遍历intervals，对每一个区间右界，以其为 target，在lefts中用二分查找，找到「大于等于」该target的左界值，不存在时返回 -1，存在则返回相应的下标。

时间复杂度：O(nlogn)，n次二分查找。

空间复杂度：O(n)。


class Solution {
    public int[] findRightInterval(int[][] intervals) {
        int n = intervals.length;
        int[] res = new int[n];
        int[][] lefts = new int[n][2]; // 左界值数组lefts[i][0]表示左界值，lefts[i][1]表示该左界值在intervals中的下标
        for(int i = 0; i < n; i++) {
            lefts[i][0] = intervals[i][0]; // 保存左界值
            lefts[i][1] = i; // 保存下标
        }
        Arrays.sort(lefts, (a, b) -> a[0] - b[0]); // 排序后lefts[i][0]表示当前第i位的左界值，lefts[i][1]表示在原intervals数组中的下标
        for(int i = 0; i < n; i++){
            res[i] = find(lefts, intervals[i][1]); // 二分查找，返回「大于等于」当前区间右界的左界所属区间下标
        }
        return res;
    }
    private int find(int[][] lefts, int target){
        int n = lefts.length, l = 0, r = n - 1;
        while(l <= r){ // 「模版一」
            int c = l + (r - l) / 2;
            if(lefts[c][0] < target) l = c + 1; // 「大于等于」情形
            else r = c - 1;
        }
        return l == n ? -1 : lefts[l][1]; // 不存在返回-1，否则返回在intervals中的下标
    }
}
// 更多题目仍在更新中

🐮🐮🐮
牛啊兄弟，你竟然真的看到这里了。

文章更新日志：

[2022-05-19]

更正「实战应用」的81题代码的一条注释。由 @yi-xing-dai-ma-qiao-yi-tian (一行代码敲一天) 同学发现，感谢🙏。详情请见回复。

新增这两日的668/462题题解。没想到昨天和今天连着两天都是二分查找的题目（5/18: 668. 乘法表中第k小的数, 5/19: 462. 最少移动次数使数组元素相等 II），难怪这篇文章眼看着就要掉出热议区前五，又被大家给捞上来了哈哈。这两题有些难度，但如果你看过本文，并且确实吃透了，那么独立做出的概率是很大的，yuki我作为一个资深小白，读题后很快就出思路，也都顺利AC（见「实战应用」）。趁热在「实战应用」中更新了这两题的题解，欢迎大家查看指正👏。（462另有「中位数」解法，可基于快速排序思想实现平均 O(n)O(n) 的时间复杂度，该解法已更新到十大排序从入门到入赘 一文的「实战应用」中。）

[2022-05-17]

经 @masterx89 (HanKai Xia) 同学指正，修改「模版二「一般」写法之情形3(正确版2)」代码中的返回值。原代码功能上正确，但存在无意义的赘行。详情可见评论区，感谢 HanKai Xia 同学！

修改了我原先对「左闭右闭」、「左闭右开」命名的错误看法，原文保留，用删除线划去。

[2022-05-15]

新增「二段性」的解释，并阐述一点个人对该名称的看法。「二段性」的内涵为「输入序列对于答案可二分至穷尽」，并指出此为二分查找的本质。

新增若干题目及题解。

[2022-05-13]

已更新这些二分题目的解析：704/69/374/33/153/154/81/278/162/34/35/74/658/29/875。仍在持续增加中。

修正 @peaceful-pasteurtdn (JamesMay) 发现的「模版二」之「相等返回」情形代码瑕疵，删去了多余的返回前判断（此种场景中只要target不存在，最后可以直接返回 -1而无需判断）。同时修改了该处代码下的一段描述和一张示意图。详情可见评论区，感谢 JamesMay 同学。

[2022-05-12]

文章标题从「深度剖析二分查找」变更为「二分查找从入门到入睡」，主要想表达，学习这篇文章后，二分查找不再成为一看就会一写就废的顽疾，遇到二分，从容应对，而后可缓缓睡矣。

新增「实战应用」一节，展示在理解本文的基础上如何轻松解题，使得“该背哪个模版？”，“该用哪个模版？”将不再成为我们解决二分问题时的考虑。该节仍在更新中，我尽量多增加一些题目。

[2022-05-11]

增加了「二分查找趣闻」，介绍了Joshua Bloch写的一篇非常有趣的博文，博文中写了二分查找算法的一些趣事和求中间值下标溢出bug的历史，抒发了他对二分查找乃至对待程序，对待bug的一些感悟。强烈推荐大家看一看这篇博文。

增加了「各语言内置二分查找方法(函数)」一节，通过源码指出Java中的binarySearch, C++中的lower_bound & upper_bound, 以及Python中的bisect_left & bisect_right方法(函数)分别对应我们介绍的哪个模版的哪种情形。

增加「左闭右闭」、「左闭右开」的描述。

增加中间值下标防溢出的三种写法及解释。

修改若干错别字。

[2022-05-10]

经@mochi-ds (知心猛男) 指正，大幅更正了本文之前宣称「模版二」无法适用于「情形3」和「情形4」的相关内容（可以适用）。详情可见评论区，非常感谢「知心猛男」的指正。
评论区入口
267

收藏

分享


回复讨论

接收动态
共 125 个回复

最热

yukiyama
L5
 · 楼主
9 天前

一个函数搞定的事也叫事
我还是直说吧，我感觉到你有一些傲慢。力扣是一个公共平台，用户层次不同，也许你很厉害，但这绝不意味着你可以随意指摘他人。指出别人的错误是需要相当谨慎的，如果文章有任何问题，我一概虚心听取即刻修改，没有谁生来就全知全能。实际上早先有个回复指出了我的一个重大纰漏，我是非常感激的，也及时修改了。一篇长文产出不易，我希望它变得更好。另外讨论是开放的，但如果你没有仔细看过我的内容，就断言我误人子弟，这很伤人。不知道你在你的生活工作环境是怎么样的，但你在我的帖子里的回复，确实令我不甚愉快。我绝没有要批评你的意思，我想我也不具备这个资格，但觉得很有必要提一点我的看法。

21

回复

收藏

分享


添加回复

Epoch
L1
2022-05-10
总结的很好, 我也分享一下我了解的吧.
除了楼主提到的模板题, 模板题还有(即C++中的lower_bound和upper_bound函数实现)

34. 在排序数组中查找元素的第一个和最后一个位置
1. 直接定义res获取答案
可以避免陷入结果究竟是取l, l+1下标对应地元素等细节问题, 如29. 两数相除


class Solution {
public:
    bool mul(int x, int n, int comp) {
        int res = 0;
        while (n) {
            if (n & 1) {
                if (res < comp - x) {
                    return false;
                }
                res = res + x;
            }
            n >>= 1;
            if (n == 0)
                break;
            else if (x < comp - x)
                return false;
            x += x;
        }
        return true;
    }

    int divide(int a, int b) {
        if (a == INT_MIN) {
            if (b == -1) {
                return INT_MAX;
            } else if (b == 1) {
                return INT_MIN;
            }
        }
        bool rev = false;
        if (a > 0) {
            a = -a;
            rev = !rev;
        }
        if (b > 0) {
            b = -b;
            rev = !rev;
        }
        int l = 0, r = INT_MAX;
        int res = 0;
        while (l <= r) {
            int mid = ((r - l) >> 1) + l;
            if (mul(b, mid, a)) {
                res = mid; //直接在符合条件的mid处, 设置为res
                if (mid == INT_MAX) {
                    break;
                }
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return rev ? -res : res;
    }
};
题解本身有点复杂, 理解用res接收答案即可.
当然, 理解到底是哪个下标取答案是很有必要的, 对于二分查找的深入理解必不可少.

2. 二分查找的应用不止于单调性, 符合二段性即可
满足二段性即可使用二分查找
不满足时候可以考虑恢复二段性

通常来说, 需要定义一个check(mid)函数来判断移动left还是right, 如例题

1482. 制作 m 束花所需的最少天数
1011. 在 D 天内送达包裹的能力
3. 拓展
这部分对二分查找的应用需要对二分查找有一个很深的理解, 给出题目

153. 寻找旋转排序数组中的最小值

154. 寻找旋转排序数组中的最小值 II

33. 搜索旋转排序数组

81. 搜索旋转排序数组 II

11

回复

收藏

分享


添加回复

mgAronya

L5
2022-05-11
写的真的好，刚开始学二分的时候老是因为边界问题出错，文章讲的很明白。

6

回复

收藏

分享


添加回复

摘星

L4
2022-05-10
这就是北邮学子吗 i了i了 平时一直看你在群上不停发表 本菜鸡只能默默观摩哈哈哈哈哈哈哈哈哈哈哈哈

6

回复

收藏

分享


添加回复

yukiyama
L5
 · 楼主
2022-05-10

并不想打击你探索的积极性，但是防止你误导新人，首先说结论：二分两个模板在你说的这四种情形都是都适用的。第二个模板你写不出来其他情况的原因，是你没有理解第二个模板在干嘛，所以写错了。 学习二分，先学明白标准库的两种对二分的定义和写法：lower_*bound() 和 upper_*bound()。 如果你没有
蛮好啊，非常感谢指教。说实话，分享心得我也是特别害怕给人传递错误信息，如果有错一定及时更正。我之前也在想模版二针对我说的那两个情形该怎么改造才能适应。但我没琢磨出来，我今天有空再想想，也期待你不吝赐教哈😄

3

回复

收藏

分享


添加回复

知心猛男
L5
2022-05-10
并不想打击你探索的积极性，但是防止你误导新人，首先说结论：二分两个模板在你说的这四种情形都是都适用的。第二个模板你写不出来其他情况的原因，是你没有理解第二个模板在干嘛，所以写错了。

学习二分，先学明白标准库的两种对二分的定义和写法：lower_*bound() 和 upper_*bound()。

如果你没有研究明白回复我，我给补上后面两个二分代码。

3

回复 2

收藏

分享


添加回复

Zhug

L2
19 小时前
太强了，写得很详细，已收藏，刚开始做二分时边界问题真的很让人头疼

2

回复

收藏

分享


添加回复

clearlife

L3
6 天前

我看好几个人提到y总，查了下大为震撼，我也来学习一下😄
y总讲的很好的，我很庆幸自己的知识体系是跟着y总构建起来的

2

回复

收藏

分享


添加回复

yukiyama
L5
 · 楼主
10 天前

不好意思有个疑问: 模板一的 <大于>,<小于等于> 本质上是一个代码模板 模板一的<大于等于>，<小于> 本质上是一个代码模板 至于对于返回值的讨论，我理解无需记忆,只需要理解两个不变式进行解析就可以了。 然后进行下列三种情况分析的套用就可以了不是么?: nums中所有元素都小于target时： nums中
朋友你好，关于你的第一个疑问，你的理解是对的，情形之间的差异很小，你说「本质」是一个代码模版问题不大。我之所以都写出来是写文章的时候追求面面俱到，怕有的人转不过弯。

关于你的第二个问题，你举的278的例子，原题保证了必然存在bad版本，因此你可以不用考虑返回前的判断，套用「模版一」或「模版二」的「大于等于」的写法后，返回 l 一定是对的。然后你接着举的 153 题的例子，并不直接对应哪一种情形，因为这一题的数组不是整体单调的，而是分为两个单调区间，但这没有多大影响。你应当这么分析，只要nums[c] >= nums[0]，c就必然在第一个单调区间中，这题要找的是第二个单调区间的第一个元素。因此nums[c] >= nums[0]后更新l = c + 1，那么更新后 l 左侧所有元素都在第一个单调区间中。而 r 的更新条件是 nums[c] < nums[0]，这表示 c 一定在第二个区间上，r = c - 1，即r更新后r的右边元素一定在第二个区间中。while结束后，你肯定已经知道 r = l - 1，r所在位置是第一个区间的最后一个元素，而 l 的位置正是第二个区间的第一个元素。如果不好想象，记得回头看下 33 题我贴的示意图。

返回 r 还是 l 的逻辑是：

你知道while结束后 l 或 r的左侧元素或右侧元素分别满足什么「循环关系」。
你知道l与r的位置关系。（只有两种情况，模版一就是 r = l - 1，模版二就是 l = r）
你知道题目要求你返回什么。
这三点你都知道了，你就知道该返回什么了。

作者：yukiyama
链接：https://leetcode.cn/circle/discuss/ooxfo8/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
